<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="What uv is and how it works.
"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="/books/uv-class/02-what-is-uv/"><meta property="og:site_name" content="Using uv to manage python projects"><meta property="og:title" content="What uv is and how it works"><meta property="og:description" content="What uv is and how it works."><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta itemprop=name content="What uv is and how it works"><meta itemprop=description content="What uv is and how it works."><meta itemprop=datePublished content="2025-12-22T00:00:00+00:00"><meta itemprop=dateModified content="2025-12-22T00:00:00+00:00"><meta itemprop=wordCount content="1956"><title>What uv is and how it works | Using uv to manage python projects</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=/books/uv-class/02-what-is-uv/><link rel=stylesheet href=/book.min.85f17b518e8256eab1e39806e72b3659c4c4eab4911a3ac293d064c90fc68a8d.css><script defer src=/fuse.min.js></script><script defer src=/en.search.min.1fb2c8337fb1b61c6748b94ffdc3b7448001d520e2000468c465985c125ef75c.js></script><link rel=alternate type=application/rss+xml href=/books/uv-class/02-what-is-uv/index.xml title="Using uv to manage python projects"></head><body dir=ltr class="book-kind-section book-type-books"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Using uv to manage python projects</span></a></h2><div class="book-search hidden"><input id=book-search-input type=text placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/posts/>What's new?</a></li></ul><ul><li><input type=checkbox id=section-5c7e9da1f7ea456d914790ef3a5c9d96 class=toggle checked>
<label for=section-5c7e9da1f7ea456d914790ef3a5c9d96 class=flex><a href=/books/uv-class/>Using uv to manage python projects</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/books/uv-class/01-installation/>Installing and Configuring uv</a><ul></ul></li><li><a href=/books/uv-class/02-what-is-uv/ class=active>What uv is and how it works</a><ul></ul></li><li><a href=/books/uv-class/03-python-projects/>A sample project and a walkthrough</a><ul></ul></li><li><a href=/books/uv-class/04-basics/>General Options and TOML</a><ul></ul></li><li><a href=/books/uv-class/05-dependencies/>Dependencies, environments, and reproducibility</a><ul></ul></li><li><a href=/books/uv-class/06-running/>Running code and tools consistently</a><ul></ul></li><li><a href=/books/uv-class/07-python/>Python Management</a><ul></ul></li><li><a href=/books/uv-class/08-build-and-publish/>Building, packaging, and publishing</a><ul></ul></li><li><a href=/books/uv-class/09-uv-migration/>uv in context: migration and judgment</a><ul></ul></li><li><a href=/books/uv-class/57-collaboration/>Project hygiene and collaboration</a><ul></ul></li><li><a href=/books/uv-class/90-python-and-c-projects/>Using uv to extend Python with C-code</a><ul></ul></li></ul></li></ul><ul><li><a href=https://github.com/isotopp/uv-class target=_blank rel=noopener>Repo for this site</a></li><li><a href=https://themes.gohugo.io/themes/hugo-book/ target=_blank rel=noopener>Made with Hugo Book</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=/icons/menu.svg class=book-icon alt=Menu></label><h3>What uv is and how it works</h3><label for=toc-control><img src=/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><a href=#what-uv-actually-does>What uv actually does</a></li><li><a href=#what-an-environment-is>What an environment is</a><ul><li><a href=#python-version>Python version</a></li><li><a href=#virtual-environments>Virtual environments</a></li></ul></li><li><a href=#intent-resolution-lockfile>Intent, Resolution, Lockfile</a></li><li><a href=#what-problem-uv-solves>What problem <code>uv</code> solves</a></li><li><a href=#from-setuppy-and-requirementstxt-to-pyprojecttoml>From <code>setup.py</code> and <code>requirements.txt</code> to <code>pyproject.toml</code></a></li><li><a href=#beyond-development-and-execution>Beyond development and execution</a></li><li><a href=#speed-and-caching>Speed and caching</a></li><li><a href=#exercises>Exercises</a><ul><li><a href=#1-core-concepts-reproduction>1. Core Concepts (Reproduction)</a></li><li><a href=#2-the-role-of-the-lockfile-reproduction>2. The Role of the Lockfile (Reproduction)</a></li><li><a href=#3-investigating-the-cache-application>3. Investigating the Cache (Application)</a></li><li><a href=#4-environment-isolation-application>4. Environment Isolation (Application)</a></li><li><a href=#5-the-works-on-my-machine-problem-transfer>5. The &ldquo;Works on My Machine&rdquo; Problem (Transfer)</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><details open><summary><strong>Summary</strong></summary><div class=markdown-inner><p>Everything in <code>uv</code> follows the same pattern: declare intent in <code>pyproject.toml</code>,
let <code>uv</code> resolve and lock dependencies in <code>uv.lock</code>, execute inside isolated environments that are recreated on the fly.</p></div></details><h1 id=what-uv-actually-does>What uv actually does<a class=anchor href=#what-uv-actually-does>#</a></h1><p>This chapter explains what <code>uv</code> actually does, beyond the shorthand “it installs dependencies”.</p><p>At its core, <code>uv</code> is a project-centric orchestration tool.
It coordinates Python versions, environments, dependencies, tools, builds, and publishing in a way that is fast,
reproducible, and difficult to misuse.</p><p>The key ideas to keep in mind throughout this chapter are:</p><ul><li>environments are isolated</li><li>environments are reproducible</li><li>environments are disposable</li><li>creating and updating environments is cheap</li></ul><p>Once these ideas are understood, most <code>uv</code> commands become self-explanatory.</p><h1 id=what-an-environment-is>What an environment is<a class=anchor href=#what-an-environment-is>#</a></h1><p>A Python environment is a concrete, runnable Python context made up of:</p><ul><li>A specific Python interpreter and stdlib, the standard library that comes with that interpreter</li><li>A set of installed third-party packages</li><li>Metadata describing how those packages were installed</li></ul><p><code>uv</code> manages all of these pieces together, instead of leaving them to separate tools and conventions.</p><h2 id=python-version>Python version<a class=anchor href=#python-version>#</a></h2><p>Every environment is built around one specific Python version, such as <code>3.11</code>, <code>3.12</code> or <code>3.14</code>.
The version determines language features, behavior of built-in modules, ABI compatibility, and
which third-party wheels can be installed.</p><p><code>uv</code> can install and manage Python interpreters themselves, or use the operating system Python interpreter.</p><blockquote class='book-hint caution'><p>Never use the system python.
Always use a <code>--managed-python</code> with <code>uv</code>.</p></blockquote><p>Using <code>uv</code> to manage python versions avoids the use of the system-managed system-python.
A Python provided by the operating system may contain modules on top of stdlib,
which may have been installed as OS packages to enable the system python to do system python things.
This makes it specific to your OS version and update level.</p><p>This Python is also managed and updated by the system,
which means it will change over time and outside your control.
This is generally ruining reproducibility, for example,
your system python and its environment will not match a CI environment – different bugs, different behavior.</p><p>Using <code>uv</code> with managed python versions gives you clean python environments with no preinstalled packages beyond stdlib,
allows you to have multiple versions (for example, for automated testing),
and makes sure the same python version is used everywhere (for example, on your machine and in CI).</p><blockquote class='book-hint tip'><p>Using <code>uv</code> with <code>--managed-python</code> is the preferred way to use <code>uv</code> and Python.</p></blockquote><p>When you request a Python version that is not present, <code>uv</code> can download and install it.
The interpreter comes with its matching standard library.
The Python version is fully isolated from system Python installations.
This is similar in spirit to tools like <code>pyenv</code>, but integrated directly into the project workflow.</p><p><code>uv</code> does not install system libraries, compilers, operating system packages or non-Python runtimes.</p><p>For example, if a Python package requires a system library (such as OpenSSL or a C compiler),
that must be provided by the operating system or container, or you need to use something like <code>conda</code>.</p><h2 id=virtual-environments>Virtual environments<a class=anchor href=#virtual-environments>#</a></h2><p>A virtual environment is a directory that contains:</p><ul><li>a link to a Python interpreter (or a copy thereof)</li><li>an isolated site-packages directory with the packages needed</li><li>Python metadata pointing to those locations</li></ul><p>It exists to ensure that packages installed for one project do not affect another.</p><p><code>uv</code> creates and manages virtual environments automatically, implicitly and very quickly.
You do not run <code>python -m venv</code>.
You do not activate environments.
You do not manually install packages.</p><p>Instead:</p><ul><li><code>uv sync</code> ensures the environment matches the lockfile</li><li><code>uv run</code> executes commands inside the environment</li></ul><p>The environment is treated as a derived artifact, not something you curate by hand.
It is also completely disposable: You do not normally notice <code>uv</code> throwing away or rebuilding your virtual environment.
It is just there, always with exactly the tools, libraries and versions you configured.</p><h1 id=intent-resolution-lockfile>Intent, Resolution, Lockfile<a class=anchor href=#intent-resolution-lockfile>#</a></h1><p>The environment contains Python packages.
The collection of Python packages on top of stdlib are called the project dependencies.
Each dependency has a version attached to it.</p><p>In the <code>pyproject.toml</code>, each dependency is declared with a range of acceptable versions for it.
Usually (and by default) that is &ldquo;any version newer than the version we used when we started using the dependency&rdquo;.
This looks like</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>dependencies = [
</span></span><span style=display:flex><span>    <span style=color:#5af78e>&#34;httpx&gt;=0.28.1&#34;</span>,
</span></span><span style=display:flex><span>]</span></span></code></pre></div><p>This is declarative, and expresses our <em>intention</em>: We say what packages we need, and what versions are acceptable.
We do not say which <em>exact</em> version is to be used.</p><p><code>uv</code> <strong>resolves</strong> dependencies by looking at the totality of all declared dependencies,
even those that are optional or separated out into other dependency groups.</p><p>It then tries to find versions that are compatible: For example, when one component depends on <code>httpx>=0.28.1</code>,
and another component we declared transitively depends on <code>httpx>=0.26.3</code>, <code>uv</code> will choose a version of
<code>httpx>=0.28.1</code>, because that is compatible with all packages that want <code>httpx</code>.</p><p>The outcome of the resolution is written to <code>uv.lock</code> and kept unchanged.
There, the exact version, file source and <code>sha</code> checksum are recorded.
The results from the <code>uv.lock</code> are used in a sync or run.</p><blockquote class='book-hint tip'><p>The <code>uv.lock</code> file is a derived file, but it <strong>must</strong> be checked in,
so that the exact same versions of packages are being used in every checkout by you, your colleages and the CI.</p></blockquote><p>This guarantees that all users of our project will use the exact same versions of all dependencies at all times,
making runs identical and reproducible, across developer machines, CI/CD environments and installations.</p><p>This is also why <em>all</em> dependency groups are taken into account <em>all</em> of the time,
even those that are not relevant for this exact install:
We do <strong>not</strong> want the version of <code>httpx</code>
that is being used to change depending on the <code>dev</code> dependencies being installed or not.</p><p>A Python project can have many dependencies.
<code>uv</code> allows us to group them into separate groups, the default group being what is needed to run the project,
and additional groups typically being things such as <code>dev</code> (containing <code>ruff</code> and <code>mypy</code>)
or <code>test</code> (containing <code>pytest</code>).</p><p>An <code>uv.lock</code> file will not change once it is created.
Upgrading versions is a conscious and reversible decision, and done with the <code>uv lock</code> command.</p><h1 id=what-problem-uv-solves>What problem <code>uv</code> solves<a class=anchor href=#what-problem-uv-solves>#</a></h1><p>Traditional Python workflows accumulate state over time:</p><ul><li>environments are created manually and forgotten</li><li>environments are shared between projects</li><li>dependencies are installed incrementally and drift</li><li>tools are installed globally and differ per machine</li></ul><p>Developers end up with a &ldquo;works on my machine&rdquo; situation, and fragile codebases:
Because virtual environments are not managed down to the checksum-level there may be subtle differences between different machines,
containers or other environments.
The development environment and the deployment environment can diverge, the process becomes fragile,
and instead of debugging code we debug environments.</p><p><code>uv</code> prevents that by avoiding this situation structurally: each project is treated as the unit of truth,
not the machine.</p><p>It also makes the environment disposable,
recreated on the fly and completely dependent on the <code>pyproject.toml</code> and the resolved <code>uv.lock</code> file.
This creates freshly created,
up-to-date and statically resolved environments
that are upgraded to new versions in a controlled and reversible process.</p><h1 id=from-setuppy-and-requirementstxt-to-pyprojecttoml>From <code>setup.py</code> and <code>requirements.txt</code> to <code>pyproject.toml</code><a class=anchor href=#from-setuppy-and-requirementstxt-to-pyprojecttoml>#</a></h1><p>Python projects historically lack a single, authoritative definition:
metadata in <code>setup.py</code> embedded in executable Python code,
dependencies in <code>requirements.txt</code> and dev tools in <code>requirements-dev.txt</code>,
plus a number of scripts scattered across files in undefined locations.</p><p>This fragmentation makes it hard to understand what a project actually is,
much less parse this in a reliable way.</p><p><code>uv</code> centers the project around <code>pyproject.toml</code>: project metadata lives in one place,
dependencies are declared explicitly,
scripts and entry points are defined once in a central place and all tooling reads the same configuration.</p><p><code>uv init</code> creates a project that already fits this model, instead of requiring manual cleanup later.</p><p><code>uv</code> does not replace version control systems like <code>git</code> (but initializes a repo and creates a skeleton <code>.gitignore</code>),
documentation conventions (but creates an empty <code>README.md</code> as a starting point),
application-specific project structure decisions (but creates the necessary scaffolding).</p><p>Using <code>uv</code> habitually, you can&rsquo;t forget to activate the environment,
won&rsquo;t accidentally install dependencies into the global interpreter, won&rsquo;t have environment drift,
and don&rsquo;t have to wait for environment recreation.</p><p>For <code>uv</code>, environments are derived artifacts and not precious state.
They are created automatically, recreated if necessary, cheap to discard and rebuilt, and not &ldquo;activated&rdquo;.</p><p>Using <code>uv</code>, projects are always isolated from each other.
Environments are never shared or re-used, state does not leak.
Multiple versions of environments, such as &ldquo;the same environment with different Python versions&rdquo; can be created and used.</p><p>Using dependency groups, <code>uv</code> also records tooling used, and tool versions.
Tools are (an optionally installable) part of the environment, they are dependencies.</p><p>This ensures identical tooling and tool versions across all developers (put your preferences into your own group!),
identical tooling in CI, reproducible results, and predictable behavior.</p><p>It collapses several categories into one:</p><ul><li>running the application</li><li>running tests</li><li>running linters</li><li>running formatters</li></ul><p>are all just commands executed inside a known environment.</p><p><code>uv</code> does not replace <code>pytest</code>, <code>ruff</code> or <code>mypy</code>, but it makes sure they are installed in defined versions,
and run with the correct interpreter across machines.</p><h1 id=beyond-development-and-execution>Beyond development and execution<a class=anchor href=#beyond-development-and-execution>#</a></h1><p>Packaging is often misunderstood as something separate from development:
build tools feel opaque,
publishing feels risky,
metadata and build logic are scattered.
Many developers avoid packaging entirely because it seems complex,
they recommend running a git checkout.</p><p><code>uv</code> integrates packaging into the same lifecycle:
project metadata is already present,
build dependencies are declared explicitly,
builds run in isolated environments,
artifacts are reproducible.</p><p>Commands like <code>uv build</code>,
<code>uv publish</code> and <code>uv tool install .</code> use the same configuration and environment model as everything else.</p><p><code>uv</code> does not replace build backends such as: setuptools, hatchling, scikit-build-core or meson-python.
Instead, it acts as a frontend, invoking these backends in a controlled, isolated way.</p><h1 id=speed-and-caching>Speed and caching<a class=anchor href=#speed-and-caching>#</a></h1><p>In <code>uv</code>, an environment is treated as disposable, and the environment is very frequently recreated.
This needs to be fast.</p><p><code>uv</code> uses a global cache, and wheels are cached across projects, resolved dependencies are reused,
builds avoid unnecessary work.
This cache is, by default, a local directory.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ uv cache dir
</span></span><span style=display:flex><span>~/.cache/uv
</span></span><span style=display:flex><span>$ uv cache size --human
</span></span><span style=display:flex><span>warning: <span style=color:#5af78e>`</span>uv cache size<span style=color:#5af78e>`</span> is experimental and may change without warning. Pass <span style=color:#5af78e>`</span>--preview-features cache-size<span style=color:#5af78e>`</span> to disable this warning.
</span></span><span style=display:flex><span>352.9MiB</span></span></code></pre></div><p>The cache prevents multiple downloads of wheels and packages,
allowing recreation of a good-sized venv in a few hundred milliseconds &ldquo;on the fly&rdquo;.</p><p>This is the foundation of <code>uv</code>&rsquo;s speed and isolation.</p><h1 id=exercises>Exercises<a class=anchor href=#exercises>#</a></h1><h2 id=1-core-concepts-reproduction>1. Core Concepts (Reproduction)<a class=anchor href=#1-core-concepts-reproduction>#</a></h2><p>What are the four key ideas about environments that <code>uv</code> promotes (as listed in the beginning of this chapter)?
Briefly explain what &ldquo;environments are disposable&rdquo; means in the context of <code>uv</code>.</p><h2 id=2-the-role-of-the-lockfile-reproduction>2. The Role of the Lockfile (Reproduction)<a class=anchor href=#2-the-role-of-the-lockfile-reproduction>#</a></h2><p>Why is it mandatory to check the <code>uv.lock</code> file into version control?
What is the difference between &ldquo;intent&rdquo; (in <code>pyproject.toml</code>) and &ldquo;resolution&rdquo; (in <code>uv.lock</code>)?</p><h2 id=3-investigating-the-cache-application>3. Investigating the Cache (Application)<a class=anchor href=#3-investigating-the-cache-application>#</a></h2><p>Run <code>uv cache dir</code> to find your local cache directory.
Then, run <code>uv cache size --human</code> (you might need to enable preview features as shown in the chapter).
How much space is your <code>uv</code> cache currently using?</p><h2 id=4-environment-isolation-application>4. Environment Isolation (Application)<a class=anchor href=#4-environment-isolation-application>#</a></h2><p>Create two new projects in separate directories using <code>uv init</code>.
Add different dependencies to each (e.g., <code>uv add requests</code> in one and <code>uv add httpx</code> in the other).
Use <code>uv run python -c "import requests"</code> and <code>uv run python -c "import httpx"</code> in both directories.
What happens, and how does this demonstrate isolation?</p><h2 id=5-the-works-on-my-machine-problem-transfer>5. The &ldquo;Works on My Machine&rdquo; Problem (Transfer)<a class=anchor href=#5-the-works-on-my-machine-problem-transfer>#</a></h2><p>A colleague says: &ldquo;I don&rsquo;t need <code>uv.lock</code>, I just use <code>requirements.txt</code> with versions like <code>requests>=2.0.0</code>.
It works fine on my machine.&rdquo;
Based on what you learned about environment drift and reproducibility,
explain to them why this approach might lead to failures in CI/CD or on a teammate&rsquo;s machine.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=/books/uv-class/01-installation/ class="flex align-center"><img src=/icons/backward.svg class=book-icon alt=Backward>
<span>Installing and Configuring uv</span>
</a></span><span><a href=/books/uv-class/03-python-projects/ class="flex align-center"><span>A sample project and a walkthrough</span>
<img src=/icons/forward.svg class=book-icon alt=Forward></a></span></div><div class=book-comments></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#what-uv-actually-does>What uv actually does</a></li><li><a href=#what-an-environment-is>What an environment is</a><ul><li><a href=#python-version>Python version</a></li><li><a href=#virtual-environments>Virtual environments</a></li></ul></li><li><a href=#intent-resolution-lockfile>Intent, Resolution, Lockfile</a></li><li><a href=#what-problem-uv-solves>What problem <code>uv</code> solves</a></li><li><a href=#from-setuppy-and-requirementstxt-to-pyprojecttoml>From <code>setup.py</code> and <code>requirements.txt</code> to <code>pyproject.toml</code></a></li><li><a href=#beyond-development-and-execution>Beyond development and execution</a></li><li><a href=#speed-and-caching>Speed and caching</a></li><li><a href=#exercises>Exercises</a><ul><li><a href=#1-core-concepts-reproduction>1. Core Concepts (Reproduction)</a></li><li><a href=#2-the-role-of-the-lockfile-reproduction>2. The Role of the Lockfile (Reproduction)</a></li><li><a href=#3-investigating-the-cache-application>3. Investigating the Cache (Application)</a></li><li><a href=#4-environment-isolation-application>4. Environment Isolation (Application)</a></li><li><a href=#5-the-works-on-my-machine-problem-transfer>5. The &ldquo;Works on My Machine&rdquo; Problem (Transfer)</a></li></ul></li></ul></nav></div></aside></main></body></html>