<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='A walkthrough of a `uv` usage, here to extend Python with two C functions.
The functionality of the C extension, "hello world", is actually unimportant.
We use it to show a build system that can drive a C-compiler, and integrate with Python to build a wheel.
'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="/books/uv-class/90-python-and-c-projects/"><meta property="og:site_name" content="Using uv to manage python projects"><meta property="og:title" content="Using uv to extend Python with C-code"><meta property="og:description" content='A walkthrough of a `uv` usage, here to extend Python with two C functions.
The functionality of the C extension, "hello world", is actually unimportant.
We use it to show a build system that can drive a C-compiler, and integrate with Python to build a wheel.'><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta itemprop=name content="Using uv to extend Python with C-code"><meta itemprop=description content='A walkthrough of a `uv` usage, here to extend Python with two C functions.
The functionality of the C extension, "hello world", is actually unimportant.
We use it to show a build system that can drive a C-compiler, and integrate with Python to build a wheel.'><meta itemprop=datePublished content="2026-01-06T00:00:00+00:00"><meta itemprop=dateModified content="2026-01-06T00:00:00+00:00"><meta itemprop=wordCount content="2801"><title>Using uv to extend Python with C-code | Using uv to manage python projects</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=/books/uv-class/90-python-and-c-projects/><link rel=stylesheet href=/book.min.85f17b518e8256eab1e39806e72b3659c4c4eab4911a3ac293d064c90fc68a8d.css><script defer src=/fuse.min.js></script><script defer src=/en.search.min.b26c0d60d0350f79c5d300b7746fd22e00fa78727f2ba331a15f0056b0542ca5.js></script><link rel=alternate type=application/rss+xml href=/books/uv-class/90-python-and-c-projects/index.xml title="Using uv to manage python projects"></head><body dir=ltr class="book-kind-section book-type-books"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Using uv to manage python projects</span></a></h2><div class="book-search hidden"><input id=book-search-input type=text placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/posts/>What's new?</a></li></ul><ul><li><input type=checkbox id=section-5c7e9da1f7ea456d914790ef3a5c9d96 class=toggle checked>
<label for=section-5c7e9da1f7ea456d914790ef3a5c9d96 class=flex><a href=/books/uv-class/>Using uv to manage python projects</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/books/uv-class/01-installation/>Installing and Configuring uv</a><ul></ul></li><li><a href=/books/uv-class/02-what-is-uv/>What uv is and how it works</a><ul></ul></li><li><a href=/books/uv-class/03-python-projects/>A sample project and a walkthrough</a><ul></ul></li><li><a href=/books/uv-class/04-the-uv-way/>Creating projects the uv way</a><ul></ul></li><li><a href=/books/uv-class/05-dependencies/>Dependencies, environments, and reproducibility</a><ul></ul></li><li><a href=/books/uv-class/06-running/>Running code and tools consistently</a><ul></ul></li><li><a href=/books/uv-class/07-collaboration/>Project hygiene and collaboration</a><ul></ul></li><li><a href=/books/uv-class/08-build-and-publish/>Building, packaging, and publishing</a><ul></ul></li><li><a href=/books/uv-class/09-uv-migration/>uv in context: migration and judgment</a><ul></ul></li><li><a href=/books/uv-class/90-python-and-c-projects/ class=active>Using uv to extend Python with C-code</a><ul></ul></li></ul></li></ul><ul><li><a href=https://github.com/isotopp/uv-class target=_blank rel=noopener>Repo for this site</a></li><li><a href=https://themes.gohugo.io/themes/hugo-book/ target=_blank rel=noopener>Made with Hugo Book</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=/icons/menu.svg class=book-icon alt=Menu></label><h3>Using uv to extend Python with C-code</h3><label for=toc-control><img src=/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><a href=#create-a-project>Create a project</a><ul><li><a href=#tests>Tests</a></li><li><a href=#writing-the-python-part-of-the-extension>Writing the Python part of the extension</a></li><li><a href=#the-c-code-for-helloext>The C code for <code>helloext</code></a></li><li><a href=#the-cmake-definition>The <code>cmake</code> definition</a></li><li><a href=#our-pyprojecttoml>Our <code>pyproject.toml</code></a></li><li><a href=#building>Building</a></li><li><a href=#installing-and-reinstalling>Installing and Reinstalling</a></li><li><a href=#running-the-tests-and-using-the-extension>Running the tests and using the extension</a></li></ul></li><li><a href=#what-can-go-wrong>What can go wrong</a><ul><li><a href=#successful-build-but-no-module-named-helloext_hello>Successful build, but <code>No module named 'helloext._hello'</code></a></li><li><a href=#editable-installs-vs-proper-installs>Editable installs vs. Proper Installs</a></li><li><a href=#we-fixed-a-bug-but-the-module-is-still-broken>We fixed a bug, but the module is still broken</a></li></ul></li><li><a href=#what-we-get>What we get</a></li></ul></nav></aside></header><article class="markdown book-article"><details open><summary><strong>Summary</strong></summary><div class=markdown-inner><p>A walkthrough of a <code>uv</code> usage, here to extend Python with two C functions.
The functionality of the C extension, &ldquo;hello world&rdquo;, is actually unimportant.
We use it to show a build system that can drive a C-compiler, and integrate with Python to build a wheel.</p></div></details><p>This walkthrough builds a small C extension to Python, &ldquo;helloext&rdquo;.
It defines two C functions that are being called from Python.
The goal is not the <code>helloext</code> funcitonality.
Instead we use it to demonstrate a different build system, how to build a Wheel with C extensions,
and how to package and install it.</p><h1 id=create-a-project>Create a project<a class=anchor href=#create-a-project>#</a></h1><p>Our project is called <code>helloext</code>.
It will use Python 3.12, and we will be using <code>--managed-python</code>.
We are using the usual <code>--package</code> structure, because what we want to write is a package, just written in C.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir helloext
</span></span><span style=display:flex><span><span style=color:#ff5c57>cd</span> helloext
</span></span><span style=display:flex><span>uv init --package --managed-python --python 3.12</span></span></code></pre></div><p>We get the usual tree:</p><pre tabindex=0><code>$ tree
.
|-- .gitignore
|-- .python-version
|-- README.md
|-- pyproject.toml
`-- src
    `-- helloext
        `-- __init__.py</code></pre><p>Our end state will look a bit differently than before:</p><pre tabindex=0><code>$ tree -a -I .git
.
|-- .gitignore
|-- .python-version
|-- CMakeLists.txt
|-- README.md
|-- pyproject.toml
|-- src
|   `-- helloext
|       |-- __init__.py
|       `-- _hello.c
|-- tests
|   `-- test_hello.py
`-- uv.lock</code></pre><p>That is, we will have our Python code for the module in <code>src/helloext/__init__.py</code>,
the C code in <code>_hello.c</code> right next to it.</p><p>We will be using a different build system that can handle C code: <code>scikit-build-core</code>.
This uses <code>cmake</code>, so we need a <code>CmakeLists.txt</code> file.</p><h2 id=tests>Tests<a class=anchor href=#tests>#</a></h2><p>We begin with writing tests that define what we want:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#78787e># cat tests/test_hello.py</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>from</span> __future__ <span style=color:#ff6ac1>import</span> annotations
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>from</span> helloext <span style=color:#ff6ac1>import</span> hellop, hellos
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>def</span> <span style=color:#57c7ff>test_hellos</span>():
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>assert</span> hellos(<span style=color:#5af78e>&#34;Kris&#34;</span>) <span style=color:#ff6ac1>==</span> <span style=color:#5af78e>&#34;Hello, Kris&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>def</span> <span style=color:#57c7ff>test_hellop</span>(capsys):
</span></span><span style=display:flex><span>    hellop(<span style=color:#5af78e>&#34;Kris&#34;</span>)
</span></span><span style=display:flex><span>    captured <span style=color:#ff6ac1>=</span> capsys<span style=color:#ff6ac1>.</span>readouterr()
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>assert</span> captured<span style=color:#ff6ac1>.</span>out <span style=color:#ff6ac1>==</span> <span style=color:#5af78e>&#34;Hello, Kris</span><span style=color:#5af78e>\n</span><span style=color:#5af78e>&#34;</span></span></span></code></pre></div><p>That is, we will be having an extension <code>helloext</code> that defines two functions, <code>hellop()</code> and <code>hellos()</code>.</p><p>One will be <code>hellop(name: str) -> None</code>.
It will take a string <code>name</code>, and print <code>Hello, {name}\n</code> with a linefeed at the end.</p><p>The other function will be <code>hellos(name: str) -> str</code>.
It will take a string <code>name</code>, and return a string <code>Hello, {name}</code> without a linefeed at the end.</p><p>We record these facts as tests, using the name &ldquo;Kris&rdquo; for testing.
The <code>hellos()</code> assertion is trivial: <code>assert hellos("Kris") == "Hello, Kris"</code>.
The <code>hellop()</code> uses <code>capsys</code> to capture system output, and then can do the same assertion on captured output.</p><h2 id=writing-the-python-part-of-the-extension>Writing the Python part of the extension<a class=anchor href=#writing-the-python-part-of-the-extension>#</a></h2><p>Our module, <code>src/helloext</code> is a module, because the directory contains a file named <code>__init__.py</code>.
This file imports what is necessary from other submodules, and collects the symbols we want to export with <code>helloext</code>,
in the <code>__all__</code> list.</p><p>This is how we get an orderly namespace:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff6ac1>from</span> __future__ <span style=color:#ff6ac1>import</span> annotations
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>from</span> ._hello <span style=color:#ff6ac1>import</span> hellop, hellos
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>__all__ <span style=color:#ff6ac1>=</span> [<span style=color:#5af78e>&#34;hellop&#34;</span>, <span style=color:#5af78e>&#34;hellos&#34;</span>]</span></span></code></pre></div><p>The module <code>._hello</code> is the C code module in the form of a <code>_hello.so</code> file in the current directory, <code>.</code>.</p><h2 id=the-c-code-for-helloext>The C code for <code>helloext</code><a class=anchor href=#the-c-code-for-helloext>#</a></h2><p>We are not going into the details of how to write Python extensions in C in this class.
But if you ever saw the structure of an extension in PHP, lua or other languages that integrate C modules,
this will look familiar to you:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#78787e>// cat src/helloext/_hello.c
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>#define PY_SSIZE_T_CLEAN
</span></span></span><span style=display:flex><span><span style=color:#78787e>#include</span> <span style=color:#78787e>&lt;Python.h&gt;</span><span style=color:#78787e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>static</span> PyObject <span style=color:#ff6ac1>*</span><span style=color:#57c7ff>hellop</span>(PyObject <span style=color:#ff6ac1>*</span>self, PyObject <span style=color:#ff6ac1>*</span>args) {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>const</span> <span style=color:#9aedfe>char</span> <span style=color:#ff6ac1>*</span>name <span style=color:#ff6ac1>=</span> <span style=color:#ff5c57>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>if</span> (<span style=color:#ff6ac1>!</span><span style=color:#57c7ff>PyArg_ParseTuple</span>(args, <span style=color:#5af78e>&#34;s&#34;</span>, <span style=color:#ff6ac1>&amp;</span>name)) {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> <span style=color:#ff5c57>NULL</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>PySys_WriteStdout</span>(<span style=color:#5af78e>&#34;Hello, %s</span><span style=color:#5af78e>\n</span><span style=color:#5af78e>&#34;</span>, name);
</span></span><span style=display:flex><span>    Py_RETURN_NONE;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>static</span> PyObject <span style=color:#ff6ac1>*</span><span style=color:#57c7ff>hellos</span>(PyObject <span style=color:#ff6ac1>*</span>self, PyObject <span style=color:#ff6ac1>*</span>args) {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>const</span> <span style=color:#9aedfe>char</span> <span style=color:#ff6ac1>*</span>name <span style=color:#ff6ac1>=</span> <span style=color:#ff5c57>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>if</span> (<span style=color:#ff6ac1>!</span><span style=color:#57c7ff>PyArg_ParseTuple</span>(args, <span style=color:#5af78e>&#34;s&#34;</span>, <span style=color:#ff6ac1>&amp;</span>name)) {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>return</span> <span style=color:#ff5c57>NULL</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>return</span> <span style=color:#57c7ff>PyUnicode_FromFormat</span>(<span style=color:#5af78e>&#34;Hello, %s&#34;</span>, name);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>static</span> PyMethodDef HelloMethods[] <span style=color:#ff6ac1>=</span> {
</span></span><span style=display:flex><span>    {<span style=color:#5af78e>&#34;hellop&#34;</span>, hellop, METH_VARARGS, <span style=color:#5af78e>&#34;Print Hello, {name} to stdout.&#34;</span>},
</span></span><span style=display:flex><span>    {<span style=color:#5af78e>&#34;hellos&#34;</span>, hellos, METH_VARARGS, <span style=color:#5af78e>&#34;Return Hello, {name} as a string.&#34;</span>},
</span></span><span style=display:flex><span>    {<span style=color:#ff5c57>NULL</span>, <span style=color:#ff5c57>NULL</span>, <span style=color:#ff9f43>0</span>, <span style=color:#ff5c57>NULL</span>}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>static</span> <span style=color:#ff6ac1>struct</span> PyModuleDef hellomodule <span style=color:#ff6ac1>=</span> {
</span></span><span style=display:flex><span>    PyModuleDef_HEAD_INIT,
</span></span><span style=display:flex><span>    <span style=color:#5af78e>&#34;_hello&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#5af78e>&#34;Example CPython extension module.&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>-</span><span style=color:#ff9f43>1</span>,
</span></span><span style=display:flex><span>    HelloMethods
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PyMODINIT_FUNC <span style=color:#57c7ff>PyInit__hello</span>(<span style=color:#9aedfe>void</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>return</span> <span style=color:#57c7ff>PyModule_Create</span>(<span style=color:#ff6ac1>&amp;</span>hellomodule);
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Read bottom to top: A module initializer creates a new module, and points to a module definition, <code>hellomodule</code>.
The module definition contains, among other metadata, an array of functions, <code>HelloMethods</code>.
This NULL terminated array contains structures that define the functions, and the way they get parameters.</p><p>Each function reads Python parameters and converts them into something C can use.
We use the Type &ldquo;s&rdquo;, which is a Python &ldquo;utf-8 with surrogates&rdquo; string.</p><p>We then call appropriate Python API functions such as <code>PySys_WriteStdout()</code> to print,
or <code>PyUnicode_FromFormat()</code> to get a formatted dynamic string from memory that Python owns.</p><p>This code now needs to be compiled: <code>cmake</code> compiles this, using the <code>CMakeLists.txt</code>,
and the <code>pyproject.toml</code> tells <code>uv</code> how to call <code>cmake</code> and set it up.</p><h2 id=the-cmake-definition>The <code>cmake</code> definition<a class=anchor href=#the-cmake-definition>#</a></h2><p>We create a file <code>CMakeLists.txt</code> in the project root:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#78787e># cat CMakeLists.txt
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>cmake_minimum_required</span>(<span style=color:#5af78e>VERSION</span> <span style=color:#5af78e>3.20</span>)<span style=color:#ff5c57>
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>project</span>(<span style=color:#5af78e>helloext</span> <span style=color:#5af78e>LANGUAGES</span> <span style=color:#5af78e>C</span>)<span style=color:#ff5c57>
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>find_package</span>(<span style=color:#5af78e>Python</span> <span style=color:#5af78e>REQUIRED</span> <span style=color:#5af78e>COMPONENTS</span> <span style=color:#5af78e>Interpreter</span> <span style=color:#5af78e>Development.Module</span>)<span style=color:#ff5c57>
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>Python_add_library</span>(<span style=color:#5af78e>_hello</span> <span style=color:#5af78e>MODULE</span> <span style=color:#5af78e>src/helloext/_hello.c</span>)<span style=color:#ff5c57>
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>set_target_properties</span>(<span style=color:#5af78e>_hello</span> <span style=color:#5af78e>PROPERTIES</span>
</span></span><span style=display:flex><span>  <span style=color:#5af78e>OUTPUT_NAME</span> <span style=color:#5af78e>&#34;_hello&#34;</span>
</span></span><span style=display:flex><span>)<span style=color:#ff5c57>
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>if</span> (<span style=color:#5af78e>WIN32</span>)<span style=color:#ff5c57>
</span></span></span><span style=display:flex><span>  <span style=color:#ff5c57>set_target_properties</span>(<span style=color:#5af78e>_hello</span> <span style=color:#5af78e>PROPERTIES</span> <span style=color:#5af78e>SUFFIX</span> <span style=color:#5af78e>&#34;.pyd&#34;</span>)<span style=color:#ff5c57>
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>endif</span>()<span style=color:#ff5c57>
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>
</span></span></span><span style=display:flex><span><span style=color:#ff5c57>install</span>(<span style=color:#5af78e>TARGETS</span> <span style=color:#5af78e>_hello</span> <span style=color:#5af78e>LIBRARY</span> <span style=color:#5af78e>DESTINATION</span> <span style=color:#5af78e>helloext</span>)</span></span></code></pre></div><p>This declares minimum version requirements, names project name and language, and finds the required components,
basically Python and the needed API includes from the SDK.</p><p>We create a library, &ldquo;_hello.so&rdquo;, which we tell <code>cmake</code> with <code>Python_add_library</code>.</p><p>We need to collect the deliverable and install it, that is,
we build a Python Wheel and the compiled artifact needs to be added to the Wheel.
This is what the <code>install()</code> line does.</p><h2 id=our-pyprojecttoml>Our <code>pyproject.toml</code><a class=anchor href=#our-pyprojecttoml>#</a></h2><p>Our <code>pyproject.toml</code> has a few special options:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#78787e># cat pyproject.toml</span>
</span></span><span style=display:flex><span>[project]
</span></span><span style=display:flex><span>name = <span style=color:#5af78e>&#34;helloext&#34;</span>
</span></span><span style=display:flex><span>version = <span style=color:#5af78e>&#34;0.1.0&#34;</span>
</span></span><span style=display:flex><span>description = <span style=color:#5af78e>&#34;Example CPython C extension with uv + scikit-build-core&#34;</span>
</span></span><span style=display:flex><span>readme = <span style=color:#5af78e>&#34;README.md&#34;</span>
</span></span><span style=display:flex><span>authors = [
</span></span><span style=display:flex><span>    { name = <span style=color:#5af78e>&#34;Kristian Koehntopp&#34;</span>, email = <span style=color:#5af78e>&#34;kris-git@koehntopp.de&#34;</span> }
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>requires-python = <span style=color:#5af78e>&#34;&gt;=3.12&#34;</span>
</span></span><span style=display:flex><span>dependencies = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[build-system]
</span></span><span style=display:flex><span>requires = [<span style=color:#5af78e>&#34;scikit-build-core&gt;=0.11&#34;</span>, ]
</span></span><span style=display:flex><span>build-backend = <span style=color:#5af78e>&#34;scikit_build_core.build&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[tool.uv]
</span></span><span style=display:flex><span>package = <span style=color:#ff6ac1>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[tool.scikit-build]
</span></span><span style=display:flex><span>cmake.version = <span style=color:#5af78e>&#34;&gt;=3.20&#34;</span>
</span></span><span style=display:flex><span><span style=color:#78787e># build.verbose = true</span>
</span></span><span style=display:flex><span>wheel.packages = [<span style=color:#5af78e>&#34;src/helloext&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[dependency-groups]
</span></span><span style=display:flex><span>dev = [
</span></span><span style=display:flex><span>    <span style=color:#5af78e>&#34;ruff&gt;=0.14.10&#34;</span>,
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>test = [
</span></span><span style=display:flex><span>    <span style=color:#5af78e>&#34;pytest&gt;=9.0.2&#34;</span>,
</span></span><span style=display:flex><span>]</span></span></code></pre></div><p>We are defining a non-standard <code>[build-system]</code>, <code>scikit-build-core.build</code> (with a minimum version requirement).</p><p>We also define a toml table <code>[tool.scikit-build]</code> to set options:</p><ul><li><code>cmake.version>=3.20</code> sets a minimum version requirement for <code>cmake</code>.
This must match the requirement in the <code>CMakeLists.txt</code> itself.</li><li><code>wheel.packages</code> tells the build system where our package to build are.</li><li>optionally we can set <code>build.verbose</code> to <code>true</code> to get more build debug output.</li></ul><p>The other options we should be familiar with by now.</p><h2 id=building>Building<a class=anchor href=#building>#</a></h2><p>We can now build:</p><pre tabindex=0><code>$ uv build
Building source distribution...
*** scikit-build-core 0.11.6 (sdist)
Building wheel from source distribution...
*** scikit-build-core 0.11.6 using CMake 4.2.1 (wheel)
*** Configuring CMake...
loading initial cache file /var/folders/dn/vtkw12w17qv7cqw5yj6lmgjh0000gn/T/tmpe31qrwbm/build/CMakeInit.txt
-- The C compiler identification is AppleClang 17.0.0.17000404
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Found Python: /Users/kris/.cache/uv/builds-v0/.tmp8Kf7xj/bin/python (found version &#34;3.12.12&#34;) found components: Interpreter Development.Module
-- Configuring done (0.4s)
-- Generating done (0.0s)
-- Build files have been written to: /var/folders/dn/vtkw12w17qv7cqw5yj6lmgjh0000gn/T/tmpe31qrwbm/build
*** Building project with Ninja...
Change Dir: &#39;/var/folders/dn/vtkw12w17qv7cqw5yj6lmgjh0000gn/T/tmpe31qrwbm/build&#39;

Run Build Command(s): /Users/kris/.cache/uv/builds-v0/.tmp8Kf7xj/bin/ninja -v
[1/2] /usr/bin/cc -D_hello_EXPORTS -isystem /Users/kris/.local/share/uv/python/cpython-3.12.12-macos-aarch64-none/include/python3.12 -O3 -DNDEBUG -arch arm64 -fPIC -MD -MT CMakeFiles/_hello.dir/src/helloext/_hello.c.o -MF CMakeFiles/_hello.dir/src/helloext/_hello.c.o.d -o CMakeFiles/_hello.dir/src/helloext/_hello.c.o -c /Users/kris/.cache/uv/sdists-v9/.tmpCf0QjY/helloext-0.2.0/src/helloext/_hello.c
[2/2] : &amp;&amp; /usr/bin/cc -O3 -DNDEBUG -arch arm64 -bundle -Wl,-headerpad_max_install_names -Xlinker -undefined -Xlinker dynamic_lookup -o _hello.so CMakeFiles/_hello.dir/src/helloext/_hello.c.o   &amp;&amp; :

*** Installing project into wheel...
-- Install configuration: &#34;Release&#34;
-- Installing: /var/folders/dn/vtkw12w17qv7cqw5yj6lmgjh0000gn/T/tmpe31qrwbm/wheel/platlib/helloext/_hello.so
*** Making wheel...
*** Created helloext-0.2.0-cp312-cp312-macosx_26_0_arm64.whl
Successfully built dist/helloext-0.2.0.tar.gz
Successfully built dist/helloext-0.2.0-cp312-cp312-macosx_26_0_arm64.whl</code></pre><p>This creates the <code>dist/</code> directory with two files in it:</p><ul><li>The <code>dist/helloext-0.2.0.tar.gz</code> with the source distribution for the wheel.</li><li>The <code>dist/helloext-0.2.0-cp312-cp312-macosx_26_0_arm64.whl</code>, which is the actual wheel.</li></ul><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kk:helloext kris$ ls -l dist
</span></span><span style=display:flex><span>total <span style=color:#ff9f43>24</span>
</span></span><span style=display:flex><span>-rw-r--r--  <span style=color:#ff9f43>1</span> kris  staff  <span style=color:#ff9f43>3338</span> Jan  <span style=color:#ff9f43>6</span> 10:31 helloext-0.2.0-cp312-cp312-macosx_26_0_arm64.whl
</span></span><span style=display:flex><span>-rw-r--r--  <span style=color:#ff9f43>1</span> kris  staff  <span style=color:#ff9f43>5605</span> Jan  <span style=color:#ff9f43>6</span> 10:31 helloext-0.2.0.tar.gz</span></span></code></pre></div><p>Our wheel contains the usual platform triple: cp312 for Python 3.12, but this time it&rsquo;s not &ldquo;None-Any&rdquo;,
because the C code is platform specific.
Instead we get the API <code>cp312</code> (CPYthon 3.12) in the API field,
and &ldquo;macosx_26_0_arm64&rdquo; for the OS field.
If our deployment needs to cover more or other platforms,
we need to set up a build farm and collect artifacts to spare our users the build.</p><p>A wheel is a ZIP file, so we can <code>unzip -v</code> this:</p><pre tabindex=0><code>kk:helloext kris$ unzip -v dist/helloext-0.2.0-cp312-cp312-macosx_26_0_arm64.whl
Archive:  dist/helloext-0.2.0-cp312-cp312-macosx_26_0_arm64.whl
 Length   Method    Size  Cmpr    Date    Time   CRC-32   Name
--------  ------  ------- ---- ---------- ----- --------  ----
     287  Defl:N      132  54% 01-06-2026 09:31 0b99c49a  helloext/__init__.py
     944  Defl:N      434  54% 01-06-2026 09:31 c98a34aa  helloext/_hello.c
   50232  Defl:N     1409  97% 01-06-2026 09:31 bd8c2210  helloext/_hello.so
     239  Defl:N      188  21% 01-06-2026 09:31 4b7d2706  helloext-0.2.0.dist-info/METADATA
     114  Defl:N      107   6% 01-06-2026 09:31 6e776e32  helloext-0.2.0.dist-info/WHEEL
     434  Defl:N      292  33% 01-06-2026 09:31 fe074413  helloext-0.2.0.dist-info/RECORD
--------          -------  ---                            -------
   52250             2562  95%                            6 files</code></pre><p>The important check here is that our wheel contains the <code>__init__.py</code> for the Python part of the module,
and the <code>_hello.so</code> for the C/machine level part of the code.</p><p>Had we left out the <code>install()</code> in the <code>CMakeLists.txt</code> file, only the native Python part would be present,
but the <code>.so</code> file would be missing.</p><h2 id=installing-and-reinstalling>Installing and Reinstalling<a class=anchor href=#installing-and-reinstalling>#</a></h2><p><code>uv</code> does not manage Non-Python parts of our environment.
We need to install a C-compiler, <code>cmake</code> or <code>ninja</code> (depending on scikit setup),
and the required tools and libraries to compile our C code.</p><p><code>uv</code> also does not manage the freshness of the C code.
Because of that we <code>--reinstall</code> or <code>--reinstall-package &lt;packagename></code> to force a recompile and reinstall of the Wheel:</p><pre tabindex=0><code>$ uv sync --reinstall --all-groups
Using CPython 3.12.12
Creating virtual environment at: .venv
Resolved 8 packages in 6ms
      Built helloext @ file:///Users/kris/Source/helloext
Prepared 7 packages in 1.33s
Installed 7 packages in 12ms
 + helloext==0.2.0 (from file:///Users/kris/Source/helloext)
 + iniconfig==2.3.0
 + packaging==25.0
 + pluggy==1.6.0
 + pygments==2.19.2
 + pytest==9.0.2
 + ruff==0.14.10</code></pre><p>We can inspect the <code>.venv</code> to see the extension and its metadata:</p><pre tabindex=0><code>kk:helloext kris$ ls -l .venv/lib/python3.12/site-packages/
total 64
-rw-r--r--   1 kris  staff    58 Jan  6 15:18 _helloext_editable.pth
-rw-r--r--   1 kris  staff  9240 Jan  6 15:18 _helloext_editable.py
drwxr-xr-x  57 kris  staff  1824 Jan  6 15:18 _pytest
-rw-r--r--   1 kris  staff    18 Jan  6 15:16 _virtualenv.pth
-rw-r--r--   1 kris  staff  4342 Jan  6 15:16 _virtualenv.py
drwxr-xr-x   3 kris  staff    96 Jan  6 15:18 helloext
drwxr-xr-x  10 kris  staff   320 Jan  6 15:18 helloext-0.1.0.dist-info
drwxr-xr-x   7 kris  staff   224 Jan  6 15:18 iniconfig
drwxr-xr-x   9 kris  staff   288 Jan  6 15:18 iniconfig-2.3.0.dist-info
drwxr-xr-x  18 kris  staff   576 Jan  6 15:18 packaging
drwxr-xr-x   8 kris  staff   256 Jan  6 15:18 packaging-25.0.dist-info
drwxr-xr-x  11 kris  staff   352 Jan  6 15:18 pluggy
drwxr-xr-x   9 kris  staff   288 Jan  6 15:18 pluggy-1.6.0.dist-info
-rw-r--r--   1 kris  staff   329 Dec 14 10:59 py.py
drwxr-xr-x  22 kris  staff   704 Jan  6 15:18 pygments
drwxr-xr-x   9 kris  staff   288 Jan  6 15:18 pygments-2.19.2.dist-info
drwxr-xr-x   5 kris  staff   160 Jan  6 15:18 pytest
drwxr-xr-x  10 kris  staff   320 Jan  6 15:18 pytest-9.0.2.dist-info
drwxr-xr-x   4 kris  staff   128 Jan  6 15:18 ruff
drwxr-xr-x   8 kris  staff   256 Jan  6 15:18 ruff-0.14.10.dist-info
kk:helloext kris$ ls -l .venv/lib/python3.12/site-packages/helloext
total 104
-rwxr-xr-x  1 kris  staff  50232 Jan  6 15:18 _hello.so</code></pre><p>The extension is in <code>.venv/lib/python3.12/site-packages/helloext</code>, and we see the <code>_hello.so</code> file in there.
The metadata is in the <code>dist-info</code> directory right next to it, with the usual metadata files.</p><h2 id=running-the-tests-and-using-the-extension>Running the tests and using the extension<a class=anchor href=#running-the-tests-and-using-the-extension>#</a></h2><p>We then can run out tests as usual, and they will now succeed, using our C code functions instead of native Python:</p><pre tabindex=0><code>$ uv run pytest
============================ test session starts =============================
platform darwin -- Python 3.12.12, pytest-9.0.2, pluggy-1.6.0
rootdir: /Users/kris/Source/helloext
configfile: pyproject.toml
collected 2 items

tests/test_hello.py ..                                                 [100%]

============================= 2 passed in 0.01s ==============================</code></pre><p>We can also test manually:</p><pre tabindex=0><code>$ uv run python
Python 3.12.12 (main, Dec 17 2025, 21:07:08) [Clang 21.1.4 ] on darwin
Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.
&gt;&gt;&gt; from helloext import hellos, hellop
&gt;&gt;&gt; hellop(&#34;Kris&#34;)
Hello, Kris
&gt;&gt;&gt; a = hellos(&#34;Kris&#34;)
&gt;&gt;&gt; print(a)
Hello, Kris</code></pre><h1 id=what-can-go-wrong>What can go wrong<a class=anchor href=#what-can-go-wrong>#</a></h1><h2 id=successful-build-but-no-module-named-helloext_hello>Successful build, but <code>No module named 'helloext._hello'</code><a class=anchor href=#successful-build-but-no-module-named-helloext_hello>#</a></h2><p>We see a successful build, and even setting the <code>verbose</code> option reveals no errors.
Yet, when we try to import the module, we get the message <code>No module named 'helloext._hello'</code>.
This is the name of the <code>.so</code> file, <code>_hello.so</code>, so we do get the Python part in the init-file, but not the C component.</p><p>This is confirmed by listing the contents of the <code>.whl</code> file in <code>dist/</code> with <code>unzip -v</code>:
There is no <code>_hello.so</code> packaged.</p><p>This happens when we forget the <code>install()</code> clause in the <code>CMakeLists.txt</code>:</p><pre tabindex=0><code>install(TARGETS _hello LIBRARY DESTINATION helloext)</code></pre><h2 id=editable-installs-vs-proper-installs>Editable installs vs. Proper Installs<a class=anchor href=#editable-installs-vs-proper-installs>#</a></h2><p>When we run <code>uv run something</code>, we run it directly from the source directory.
The include path that Python uses is expanded, so that modules in <code>src</code> can be found and used.
This is called an &ldquo;editable install&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>kk:helloext kris<span style=color:#ff5c57>$</span> uv run python
</span></span><span style=display:flex><span>Python <span style=color:#ff9f43>3.12.12</span> (main, Dec <span style=color:#ff9f43>17</span> <span style=color:#ff9f43>2025</span>, <span style=color:#ff9f43>21</span>:<span style=color:#ff9f43>07</span>:<span style=color:#ff9f43>08</span>) [Clang <span style=color:#ff9f43>21.1.4</span> ] on darwin
</span></span><span style=display:flex><span>Type <span style=color:#5af78e>&#34;help&#34;</span>, <span style=color:#5af78e>&#34;copyright&#34;</span>, <span style=color:#5af78e>&#34;credits&#34;</span> <span style=color:#ff6ac1>or</span> <span style=color:#5af78e>&#34;license&#34;</span> <span style=color:#ff6ac1>for</span> more information<span style=color:#ff6ac1>.</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>&gt;&gt;&gt;</span> <span style=color:#ff6ac1>import</span> pprint
</span></span><span style=display:flex><span><span style=color:#ff6ac1>&gt;&gt;&gt;</span> <span style=color:#ff6ac1>import</span> sys
</span></span><span style=display:flex><span><span style=color:#ff6ac1>&gt;&gt;&gt;</span> pprint<span style=color:#ff6ac1>.</span>pprint(sys<span style=color:#ff6ac1>.</span>path)
</span></span><span style=display:flex><span>[<span style=color:#5af78e>&#39;&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#5af78e>&#39;/Users/kris/.local/share/uv/python/cpython-3.12.12-macos-aarch64-none/lib/python312.zip&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#5af78e>&#39;/Users/kris/.local/share/uv/python/cpython-3.12.12-macos-aarch64-none/lib/python3.12&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#5af78e>&#39;/Users/kris/.local/share/uv/python/cpython-3.12.12-macos-aarch64-none/lib/python3.12/lib-dynload&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#5af78e>&#39;/Users/kris/Source/helloext/.venv/lib/python3.12/site-packages&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#5af78e>&#39;/Users/kris/Source/helloext/src&#39;</span>]</span></span></code></pre></div><p>This works with pure python modules, because this will make <code>import helloext</code> search <code>src/helloext</code>,
the interpreter will find the module and import it.</p><p>The C compiler bulld system does the build elsewhere and does not put the module into <code>src/helloext</code>.</p><p>SciKit works around that by putting hooks into <code>site-packages</code>:</p><pre tabindex=0><code>kk:helloext kris$ ls -l .venv/lib/python3.12/site-packages/
total 56
drwxr-xr-x   4 kris  staff   128 Jan  6 16:30 __pycache__
-rw-r--r--   1 kris  staff    58 Jan  6 16:42 _helloext_editable.pth
-rw-r--r--   1 kris  staff  9240 Jan  6 16:42 _helloext_editable.py
-rw-r--r--   1 kris  staff    18 Jan  6 16:30 _virtualenv.pth
-rw-r--r--   1 kris  staff  4342 Jan  6 16:30 _virtualenv.py
drwxr-xr-x   3 kris  staff    96 Jan  6 16:42 helloext
drwxr-xr-x  10 kris  staff   320 Jan  6 16:42 helloext-0.2.0.dist-info
drwxr-xr-x   4 kris  staff   128 Jan  6 16:30 ruff
drwxr-xr-x   8 kris  staff   256 Jan  6 16:30 ruff-0.14.10.dist-info</code></pre><p>The <code>.venv/lib/python&lt;versio>/site-packages/_helloext_editable.py</code> contains Python source that extents the <code>sys.path</code>,
but also provides hooks to load <code>.venv/lib/python&lt;versio>/site-packages/helloext/_hello.so</code>.</p><p>If you check, you will find code that looks similar to this:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff6ac1>def</span> <span style=color:#57c7ff>install</span>(
</span></span><span style=display:flex><span>    known_source_files: <span style=color:#ff5c57>dict</span>[<span style=color:#ff5c57>str</span>, <span style=color:#ff5c57>str</span>],
</span></span><span style=display:flex><span>    known_wheel_files: <span style=color:#ff5c57>dict</span>[<span style=color:#ff5c57>str</span>, <span style=color:#ff5c57>str</span>],
</span></span><span style=display:flex><span>    path: <span style=color:#ff5c57>str</span> <span style=color:#ff6ac1>|</span> <span style=color:#ff6ac1>None</span>,
</span></span><span style=display:flex><span>    rebuild: <span style=color:#ff5c57>bool</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>False</span>,
</span></span><span style=display:flex><span>    verbose: <span style=color:#ff5c57>bool</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>False</span>,
</span></span><span style=display:flex><span>    build_options: <span style=color:#ff5c57>list</span>[<span style=color:#ff5c57>str</span>] <span style=color:#ff6ac1>|</span> <span style=color:#ff6ac1>None</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>None</span>,
</span></span><span style=display:flex><span>    install_options: <span style=color:#ff5c57>list</span>[<span style=color:#ff5c57>str</span>] <span style=color:#ff6ac1>|</span> <span style=color:#ff6ac1>None</span> <span style=color:#ff6ac1>=</span> <span style=color:#ff6ac1>None</span>,
</span></span><span style=display:flex><span>    install_dir: <span style=color:#ff5c57>str</span> <span style=color:#ff6ac1>=</span> <span style=color:#5af78e>&#34;&#34;</span>,
</span></span><span style=display:flex><span>) <span style=color:#ff6ac1>-&gt;</span> <span style=color:#ff6ac1>None</span>:
</span></span><span style=display:flex><span>    <span style=color:#5af78e>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#5af78e>    Install a meta path finder that redirects imports to the source files, and
</span></span></span><span style=display:flex><span><span style=color:#5af78e>    optionally rebuilds if path is given.
</span></span></span><span style=display:flex><span><span style=color:#5af78e>
</span></span></span><span style=display:flex><span><span style=color:#5af78e>    :param known_source_files: A mapping of module names to source files
</span></span></span><span style=display:flex><span><span style=color:#5af78e>    :param known_wheel_files: A mapping of module names to wheel files
</span></span></span><span style=display:flex><span><span style=color:#5af78e>    :param path: The path to the build directory, or None
</span></span></span><span style=display:flex><span><span style=color:#5af78e>    :param verbose: Whether to print the cmake commands (also controlled by the
</span></span></span><span style=display:flex><span><span style=color:#5af78e>                    SKBUILD_EDITABLE_VERBOSE environment variable)
</span></span></span><span style=display:flex><span><span style=color:#5af78e>    :param install_dir: The wheel install directory override, if one was
</span></span></span><span style=display:flex><span><span style=color:#5af78e>                        specified
</span></span></span><span style=display:flex><span><span style=color:#5af78e>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    sys<span style=color:#ff6ac1>.</span>meta_path<span style=color:#ff6ac1>.</span>insert(
</span></span><span style=display:flex><span>        <span style=color:#ff9f43>0</span>,
</span></span><span style=display:flex><span>        ScikitBuildRedirectingFinder(
</span></span><span style=display:flex><span>            known_source_files,
</span></span><span style=display:flex><span>            known_wheel_files,
</span></span><span style=display:flex><span>            path,
</span></span><span style=display:flex><span>            rebuild,
</span></span><span style=display:flex><span>            verbose,
</span></span><span style=display:flex><span>            build_options <span style=color:#ff6ac1>or</span> [],
</span></span><span style=display:flex><span>            install_options <span style=color:#ff6ac1>or</span> [],
</span></span><span style=display:flex><span>            DIR,
</span></span><span style=display:flex><span>            install_dir,
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>install({<span style=color:#5af78e>&#39;helloext&#39;</span>: <span style=color:#5af78e>&#39;/Users/kris/Source/helloext/src/helloext/__init__.py&#39;</span>,
</span></span><span style=display:flex><span>         <span style=color:#5af78e>&#39;helloext._hello&#39;</span>: <span style=color:#5af78e>&#39;/Users/kris/Source/helloext/src/helloext/_hello.c&#39;</span>},
</span></span><span style=display:flex><span>        {<span style=color:#5af78e>&#39;helloext._hello&#39;</span>: <span style=color:#5af78e>&#39;helloext/_hello.so&#39;</span>}, <span style=color:#ff6ac1>None</span>, <span style=color:#ff6ac1>False</span>, <span style=color:#ff6ac1>True</span>, [], [], <span style=color:#5af78e>&#39;&#39;</span>)</span></span></code></pre></div><p>This will try to wire things together even for editable installs.</p><p>Running <code>uv sync --reinstall-package helloext --no-cache --no-editable</code> will instead install all files into
<code>.venv/lib/python&lt;versio>/site-packages/helloext/</code> as one expects, and also not put <code>src</code> into the search path:</p><pre tabindex=0><code>$ ls -l .venv/lib/python3.12/site-packages/helloext
total 120
-rw-r--r--  1 kris  staff    287 Jan  6 16:46 __init__.py
-rw-r--r--  1 kris  staff    944 Jan  6 16:46 _hello.c
-rwxr-xr-x  1 kris  staff  50232 Jan  6 16:46 _hello.so
kk:helloext kris$ uv run --no-cache --no-editable python
Python 3.12.12 (main, Dec 17 2025, 21:07:08) [Clang 21.1.4 ] on darwin
Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.
&gt;&gt;&gt; import pprint
&gt;&gt;&gt; import sys
&gt;&gt;&gt; pprint.pprint(sys.path)
[&#39;&#39;,
 &#39;/Users/kris/.local/share/uv/python/cpython-3.12.12-macos-aarch64-none/lib/python312.zip&#39;,
 &#39;/Users/kris/.local/share/uv/python/cpython-3.12.12-macos-aarch64-none/lib/python3.12&#39;,
 &#39;/Users/kris/.local/share/uv/python/cpython-3.12.12-macos-aarch64-none/lib/python3.12/lib-dynload&#39;,
 &#39;/Users/kris/Source/helloext/.venv/lib/python3.12/site-packages&#39;]</code></pre><p>So we can see that SciKit goes to considerable lengths to set up the import path and environment for us,
even when we use an editable layout.</p><p>But &ldquo;editable&rdquo; is a Python thing, and <code>uv</code> scope ends at Python boundaries.
We still have to make sure SciKit knows things, and things are being rebuild when we change C sources.</p><h2 id=we-fixed-a-bug-but-the-module-is-still-broken>We fixed a bug, but the module is still broken<a class=anchor href=#we-fixed-a-bug-but-the-module-is-still-broken>#</a></h2><p>When we fix bugs in the C source, it may be that <code>uv</code> and Scikit work together to produce a new wheel,
but in testing the old wheel is still being used.</p><p>We can work around that by diligently increasing the version number:</p><pre tabindex=0><code>uv version --bump patch</code></pre><p>to increase the rightmost version number for a versioned compile.</p><p>Or we can tell <code>uv sync</code>, <code>uv run</code> and friends to not use the cache, and force-reinstall</p><pre tabindex=0><code>uv run --all-groups --reinstall-package helloext ...</code></pre><p>to force a fresh and uncached install.</p><h1 id=what-we-get>What we get<a class=anchor href=#what-we-get>#</a></h1><p>We get an extension for Python written in C that can be called like a native Python function.</p><p>It is delivered as an installable wheel with ABI and OS specific entries in the platform tuple,
so we potentially need a build farm to satisfy our supported platforms.</p><p>We can then <code>import</code> the C-module and use it.</p><p>We have tooling to drive the C build, but this part of the build is not managed by <code>uv</code>,
so it is our responsibility to drive the C part of the build.
This includes providing the compiler, the includes and SDKs or other parts of the Non-Python build.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=/books/uv-class/09-uv-migration/ class="flex align-center"><img src=/icons/backward.svg class=book-icon alt=Backward>
<span>uv in context: migration and judgment</span>
</a></span><span></span></div><div class=book-comments></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#create-a-project>Create a project</a><ul><li><a href=#tests>Tests</a></li><li><a href=#writing-the-python-part-of-the-extension>Writing the Python part of the extension</a></li><li><a href=#the-c-code-for-helloext>The C code for <code>helloext</code></a></li><li><a href=#the-cmake-definition>The <code>cmake</code> definition</a></li><li><a href=#our-pyprojecttoml>Our <code>pyproject.toml</code></a></li><li><a href=#building>Building</a></li><li><a href=#installing-and-reinstalling>Installing and Reinstalling</a></li><li><a href=#running-the-tests-and-using-the-extension>Running the tests and using the extension</a></li></ul></li><li><a href=#what-can-go-wrong>What can go wrong</a><ul><li><a href=#successful-build-but-no-module-named-helloext_hello>Successful build, but <code>No module named 'helloext._hello'</code></a></li><li><a href=#editable-installs-vs-proper-installs>Editable installs vs. Proper Installs</a></li><li><a href=#we-fixed-a-bug-but-the-module-is-still-broken>We fixed a bug, but the module is still broken</a></li></ul></li><li><a href=#what-we-get>What we get</a></li></ul></nav></div></aside></main></body></html>