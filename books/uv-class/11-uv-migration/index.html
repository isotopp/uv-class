<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Comparing uv with pip, venv, and Poetry, understanding tool boundaries, and learning how to migrate existing projects to uv.
"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="/books/uv-class/11-uv-migration/"><meta property="og:site_name" content="Using uv to manage python projects"><meta property="og:title" content="uv in context: migration and judgment"><meta property="og:description" content="Comparing uv with pip, venv, and Poetry, understanding tool boundaries, and learning how to migrate existing projects to uv."><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta itemprop=name content="uv in context: migration and judgment"><meta itemprop=description content="Comparing uv with pip, venv, and Poetry, understanding tool boundaries, and learning how to migrate existing projects to uv."><meta itemprop=datePublished content="2025-12-22T00:00:00+00:00"><meta itemprop=dateModified content="2025-12-22T00:00:00+00:00"><meta itemprop=wordCount content="1212"><title>uv in context: migration and judgment | Using uv to manage python projects</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=/books/uv-class/11-uv-migration/><link rel=stylesheet href=/book.min.85f17b518e8256eab1e39806e72b3659c4c4eab4911a3ac293d064c90fc68a8d.css><script defer src=/fuse.min.js></script><script defer src=/en.search.min.785126d47e840e024c25e0e90412facd1cd335def5bf969cbaa80f8d48e63419.js></script><link rel=alternate type=application/rss+xml href=/books/uv-class/11-uv-migration/index.xml title="Using uv to manage python projects"></head><body dir=ltr class="book-kind-section book-type-books"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Using uv to manage python projects</span></a></h2><div class="book-search hidden"><input id=book-search-input type=text placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/posts/>What's new?</a></li></ul><ul><li><input type=checkbox id=section-5c7e9da1f7ea456d914790ef3a5c9d96 class=toggle checked>
<label for=section-5c7e9da1f7ea456d914790ef3a5c9d96 class=flex><a href=/books/uv-class/>Using uv to manage python projects</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/books/uv-class/01-installation/>Installing and Configuring uv</a><ul></ul></li><li><a href=/books/uv-class/02-what-is-uv/>What uv is and how it works</a><ul></ul></li><li><a href=/books/uv-class/03-python-projects/>A sample project and a walkthrough</a><ul></ul></li><li><a href=/books/uv-class/04-basics/>General Options and TOML</a><ul></ul></li><li><a href=/books/uv-class/05-dependencies/>Dependencies, environments, and reproducibility</a><ul></ul></li><li><a href=/books/uv-class/06-running/>Running code and tools consistently</a><ul></ul></li><li><a href=/books/uv-class/07-python/>Python Management</a><ul></ul></li><li><a href=/books/uv-class/08-build-and-publish/>Building, packaging, and publishing</a><ul></ul></li><li><a href=/books/uv-class/09-python-and-c-projects/>Using uv to extend Python with C-code</a><ul></ul></li><li><a href=/books/uv-class/10-collaboration/>Project hygiene and collaboration</a><ul></ul></li><li><a href=/books/uv-class/11-uv-migration/ class=active>uv in context: migration and judgment</a><ul></ul></li></ul></li></ul><ul><li><a href=https://github.com/isotopp/uv-class target=_blank rel=noopener>Repo for this site</a></li><li><a href=https://themes.gohugo.io/themes/hugo-book/ target=_blank rel=noopener>Made with Hugo Book</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=/icons/menu.svg class=book-icon alt=Menu></label><h3>uv in context: migration and judgment</h3><label for=toc-control><img src=/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><a href=#uv-vs-pip--venv><code>uv</code> vs. <code>pip</code> + <code>venv</code></a></li><li><a href=#uv-vs-poetry><code>uv</code> vs. <code>Poetry</code></a></li><li><a href=#when-uv-is-sufficient>When <code>uv</code> is sufficient</a><ul><li><ul><li><a href=#uv-is-enough-when><code>uv</code> is enough when:</a></li><li><a href=#you-might-need-other-tools-when>You might need other tools when:</a></li></ul></li></ul></li><li><a href=#migration-principles>Migration Principles</a><ul><li><a href=#from-pip--venv-to-uv>From <code>pip</code> + <code>venv</code> to <code>uv</code></a></li><li><a href=#from-poetry-to-uv>From <code>Poetry</code> to <code>uv</code></a></li></ul></li><li><a href=#judgment-over-tool-worship>Judgment over Tool Worship</a></li><li><a href=#exercises>Exercises</a><ul><li><a href=#1-uv-vs-pip--venv>1. <code>uv</code> vs. <code>pip</code> + <code>venv</code></a></li><li><a href=#2-uv-vs-poetry>2. <code>uv</code> vs. <code>Poetry</code></a></li><li><a href=#3-when-uv-is-sufficient>3. When <code>uv</code> is sufficient</a></li><li><a href=#4-migration-principles>4. Migration Principles</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><details open><summary><strong>Summary</strong></summary><div class=markdown-inner><p><strong>uv vs. Traditional Tools:</strong> <code>uv</code> replaces <code>pip</code>, <code>venv</code>, and <code>pip-tools</code> with a single, significantly faster, and more reliable tool.</p><p><strong>uv vs. Poetry:</strong> While <code>Poetry</code> is a mature all-in-one solution, <code>uv</code> offers superior speed and follows modern standards more closely, though it has slightly different design philosophies regarding environment management.</p><p><strong>Tool Boundaries:</strong> <code>uv</code> is excellent for project and tool management, but it doesn&rsquo;t replace task runners (like <code>make</code> or <code>just</code>) or complex system-level package managers (like <code>conda</code> or <code>nix</code>) for non-Python dependencies.</p><p><strong>Migration:</strong> Moving to <code>uv</code> is straightforward. From <code>pip</code>, it involves initializing a project and adding existing requirements. From <code>Poetry</code>, it means translating <code>pyproject.toml</code> sections and letting <code>uv</code> generate a new lockfile.</p></div></details><p>The final chapter places uv in the wider Python ecosystem.
It teaches comparison, trade-offs, and judgment, not tool worship.
Students learn when uv is enough and when additional tools are justified.</p><h1 id=uv-vs-pip--venv><code>uv</code> vs. <code>pip</code> + <code>venv</code><a class=anchor href=#uv-vs-pip--venv>#</a></h1><p>For years, the standard way to manage Python projects was the combination of <code>pip</code> (to install packages)
and <code>venv</code> (to create isolated environments).
While this works, it often requires additional tools like <code>pip-tools</code> (for <code>pip-compile</code> and <code>pip-sync</code>)
to achieve a reproducible lockfile workflow.</p><table><thead><tr><th style=text-align:left>Feature</th><th style=text-align:left><code>pip</code> + <code>venv</code></th><th style=text-align:left><code>uv</code></th></tr></thead><tbody><tr><td style=text-align:left><strong>Speed</strong></td><td style=text-align:left>Often slow, especially for large dependency trees.</td><td style=text-align:left>Extremely fast (written in Rust, uses aggressive caching).</td></tr><tr><td style=text-align:left><strong>Reproducibility</strong></td><td style=text-align:left>Requires manual management of <code>requirements.txt</code> or <code>pip-compile</code>.</td><td style=text-align:left>Built-in <code>uv.lock</code> ensures identical environments by default.</td></tr><tr><td style=text-align:left><strong>Integration</strong></td><td style=text-align:left>Separate tools for env creation, installation, and locking.</td><td style=text-align:left>Single unified tool for the entire project lifecycle.</td></tr><tr><td style=text-align:left><strong>Python Management</strong></td><td style=text-align:left>Requires external tools like <code>pyenv</code> or manual installation.</td><td style=text-align:left>Automatically downloads and manages Python versions.</td></tr></tbody></table><p><code>uv</code> replaces this fragmented workflow with a single, fast, and cohesive experience. You no longer need to remember to &ldquo;activate&rdquo; an environment; <code>uv run</code> handles it for you.</p><h1 id=uv-vs-poetry><code>uv</code> vs. <code>Poetry</code><a class=anchor href=#uv-vs-poetry>#</a></h1><p><code>Poetry</code> was the first major tool to bring the &ldquo;all-in-one&rdquo; experience to Python, inspired by tools like Rust&rsquo;s <code>cargo</code> or Node&rsquo;s <code>npm</code>. <code>uv</code> follows a similar philosophy but with some key differences.</p><table><thead><tr><th style=text-align:left>Feature</th><th style=text-align:left><code>Poetry</code></th><th style=text-align:left><code>uv</code></th></tr></thead><tbody><tr><td style=text-align:left><strong>Performance</strong></td><td style=text-align:left>Known for slow resolution times in complex projects.</td><td style=text-align:left>Designed for near-instant resolution and installation.</td></tr><tr><td style=text-align:left><strong>Standards</strong></td><td style=text-align:left>Uses its own <code>poetry.lock</code> and (historically) custom <code>pyproject.toml</code> sections.</td><td style=text-align:left>Follows PEP standards (like PEP 621) and uses a standard <code>uv.lock</code>.</td></tr><tr><td style=text-align:left><strong>Environment</strong></td><td style=text-align:left>Manages environments in a central location by default.</td><td style=text-align:left>Defaults to a local <code>.venv</code> in the project directory.</td></tr><tr><td style=text-align:left><strong>Python Management</strong></td><td style=text-align:left>Can switch versions but doesn&rsquo;t download them automatically.</td><td style=text-align:left>Full lifecycle management of Python interpreters.</td></tr></tbody></table><p>While <code>Poetry</code> is mature and feature-rich, <code>uv</code> is often preferred for its performance and closer adherence to modern Python packaging standards.</p><h1 id=when-uv-is-sufficient>When <code>uv</code> is sufficient<a class=anchor href=#when-uv-is-sufficient>#</a></h1><p><code>uv</code> is an incredibly powerful tool, but it&rsquo;s important to understand its boundaries.</p><h3 id=uv-is-enough-when><code>uv</code> is enough when:<a class=anchor href=#uv-is-enough-when>#</a></h3><ul><li>You are developing Python applications or libraries.</li><li>You need fast, reproducible environments for development and CI/CD.</li><li>You want to manage Python versions and CLI tools easily.</li><li>You are building standard wheels and source distributions.</li></ul><h3 id=you-might-need-other-tools-when>You might need other tools when:<a class=anchor href=#you-might-need-other-tools-when>#</a></h3><ul><li><strong>Task Running:</strong> While <code>uv run</code> can execute anything, it&rsquo;s not a task runner. For complex build pipelines or multi-language projects, use <code>make</code>, <code>just</code>, or <code>task</code>.</li><li><strong>System Dependencies:</strong> <code>uv</code> manages Python packages. If your project requires non-Python libraries (like <code>libxml2</code>, <code>cuda</code>, or <code>ffmpeg</code>) that aren&rsquo;t available as wheels, you still need system package managers (like <code>apt</code>, <code>brew</code>) or <code>conda</code>/<code>pixi</code>.</li><li><strong>Complex Data Science:</strong> In environments where everything (including the GPU drivers and C libraries) must be perfectly versioned together, <code>conda</code> or <code>mamba</code> remains the standard.</li></ul><h1 id=migration-principles>Migration Principles<a class=anchor href=#migration-principles>#</a></h1><p>Moving an existing project to <code>uv</code> is usually a matter of minutes.</p><h2 id=from-pip--venv-to-uv>From <code>pip</code> + <code>venv</code> to <code>uv</code><a class=anchor href=#from-pip--venv-to-uv>#</a></h2><p>If you have a project with a <code>requirements.txt</code> or a <code>setup.py</code>:</p><ol><li><strong>Initialize:</strong> Run <code>uv init --package</code> (or just <code>uv init</code> for non-packages) in your project root.</li><li><strong>Add Dependencies:</strong> Instead of editing <code>pyproject.toml</code> manually, use <code>uv add</code> to import your existing requirements:<div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>uv add -r requirements.txt</span></span></code></pre></div>If you have development requirements:<div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>uv add --dev -r requirements-dev.txt</span></span></code></pre></div></li><li><strong>Sync:</strong> Run <code>uv sync</code>. This will create the <code>.venv</code> and generate the <code>uv.lock</code> file.</li><li><strong>Cleanup:</strong> You can now remove your old <code>venv</code> directory and <code>requirements.txt</code> files (after verifying everything works).</li></ol><h2 id=from-poetry-to-uv>From <code>Poetry</code> to <code>uv</code><a class=anchor href=#from-poetry-to-uv>#</a></h2><p>Migrating from <code>Poetry</code> is even easier because <code>Poetry</code> already uses <code>pyproject.toml</code>.</p><ol><li><strong>Translate Metadata:</strong> <code>Poetry</code> uses <code>[tool.poetry]</code> for metadata. You should move this to the standard <code>[project]</code> section. <code>uv</code> can help with this, or you can use a tool like <code>poetry-to-standard</code>.<ul><li><code>name</code>, <code>version</code>, <code>description</code>, <code>authors</code> go into <code>[project]</code>.</li><li><code>dependencies</code> go into <code>[project.dependencies]</code>.</li><li><code>dev-dependencies</code> go into <code>[dependency-groups]</code>.</li></ul></li><li><strong>Generate Lockfile:</strong> <code>uv</code> does not read <code>poetry.lock</code>. Simply run:<div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>uv lock</span></span></code></pre></div><code>uv</code> will resolve the dependencies based on your <code>pyproject.toml</code> and create a new <code>uv.lock</code>.</li><li><strong>Verify:</strong> Run your tests with <code>uv run pytest</code> to ensure the environment is correct.</li></ol><h1 id=judgment-over-tool-worship>Judgment over Tool Worship<a class=anchor href=#judgment-over-tool-worship>#</a></h1><p>The goal of this book isn&rsquo;t to make you a &ldquo;<code>uv</code> fan.&rdquo;
Using <code>uv</code> alone will do that.
:-)
It&rsquo;s to make you a more productive Python developer.</p><p>The &ldquo;uv way&rdquo; is about:</p><ul><li><strong>Reducing Friction:</strong> Spend less time fighting environments and more time writing code.</li><li><strong>Ensuring Correctness:</strong> Use lockfiles and isolated environments to avoid &ldquo;it works on my machine.&rdquo;</li><li><strong>Embracing Standards:</strong> Stick to PEP-compliant configurations so your project remains portable.</li></ul><p>Whether you use <code>uv</code>, <code>Poetry</code>, or <code>pip</code>, the principles of <strong>isolation</strong>, <strong>reproducibility</strong>, and <strong>declarative intent</strong> remain the most important tools in your belt.</p><h1 id=exercises>Exercises<a class=anchor href=#exercises>#</a></h1><h2 id=1-uv-vs-pip--venv>1. <code>uv</code> vs. <code>pip</code> + <code>venv</code><a class=anchor href=#1-uv-vs-pip--venv>#</a></h2><ul><li><strong>Reproduction:</strong> Name two tools that are often required in a traditional <code>pip</code> + <code>venv</code> workflow to achieve reproducibility, which <code>uv</code> replaces natively.</li><li><strong>Reproduction:</strong> How does <code>uv</code> handle Python version management compared to the traditional <code>pip</code> + <code>venv</code> approach?</li><li><strong>Application:</strong> A developer is tired of manually activating virtual environments. Explain how <code>uv run</code> changes this workflow.</li><li><strong>Application:</strong> Compare the speed and caching mechanisms of <code>pip</code> versus <code>uv</code> when dealing with large dependency trees.</li></ul><h2 id=2-uv-vs-poetry>2. <code>uv</code> vs. <code>Poetry</code><a class=anchor href=#2-uv-vs-poetry>#</a></h2><ul><li><strong>Reproduction:</strong> What is the primary difference between <code>Poetry</code> and <code>uv</code> regarding where virtual environments are stored by default?</li><li><strong>Reproduction:</strong> How do <code>Poetry</code> and <code>uv</code> differ in their adherence to modern PEP standards (like PEP 621) for <code>pyproject.toml</code>?</li><li><strong>Application:</strong> A project uses a complex set of legacy <code>poetry.lock</code> files. Can <code>uv</code> use these files directly? Explain why or why not.</li><li><strong>Application:</strong> Compare the dependency resolution performance of <code>Poetry</code> and <code>uv</code> in large-scale projects based on the comparison table in this chapter.</li></ul><h2 id=3-when-uv-is-sufficient>3. When <code>uv</code> is sufficient<a class=anchor href=#3-when-uv-is-sufficient>#</a></h2><ul><li><strong>Reproduction:</strong> List three scenarios where <code>uv</code> is considered sufficient for a Python project&rsquo;s lifecycle.</li><li><strong>Reproduction:</strong> When might you still need a tool like <code>make</code> or <code>just</code> alongside <code>uv</code>?</li><li><strong>Application:</strong> You are working on a project that requires <code>ffmpeg</code> and <code>libxml2</code>. Explain why <code>uv</code> alone is not enough to manage these dependencies and what type of tool you should use instead.</li><li><strong>Application:</strong> A data science project requires specific GPU drivers and C libraries to be perfectly versioned with Python. Why might <code>conda</code> or <code>mamba</code> be a preferred choice over <code>uv</code> in this specific case?</li></ul><h2 id=4-migration-principles>4. Migration Principles<a class=anchor href=#4-migration-principles>#</a></h2><ul><li><strong>Reproduction:</strong> What is the first command you should run when migrating a <code>pip</code>-based project to <code>uv</code>?</li><li><strong>Reproduction:</strong> When migrating from <code>Poetry</code>, which section of the <code>pyproject.toml</code> contains the metadata that must be moved to the standard <code>[project]</code> section?</li><li><strong>Application:</strong> You have a legacy <code>requirements.txt</code> and a <code>requirements-dev.txt</code>. Show the <code>uv</code> commands to import both into a new <code>uv</code> project with appropriate grouping.</li><li><strong>Application:</strong> After translating <code>pyproject.toml</code> metadata from a <code>Poetry</code> project, what is the final step to ensure the environment is correctly set up and verified with <code>uv</code>?</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=/books/uv-class/10-collaboration/ class="flex align-center"><img src=/icons/backward.svg class=book-icon alt=Backward>
<span>Project hygiene and collaboration</span>
</a></span><span></span></div><div class=book-comments></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#uv-vs-pip--venv><code>uv</code> vs. <code>pip</code> + <code>venv</code></a></li><li><a href=#uv-vs-poetry><code>uv</code> vs. <code>Poetry</code></a></li><li><a href=#when-uv-is-sufficient>When <code>uv</code> is sufficient</a><ul><li><ul><li><a href=#uv-is-enough-when><code>uv</code> is enough when:</a></li><li><a href=#you-might-need-other-tools-when>You might need other tools when:</a></li></ul></li></ul></li><li><a href=#migration-principles>Migration Principles</a><ul><li><a href=#from-pip--venv-to-uv>From <code>pip</code> + <code>venv</code> to <code>uv</code></a></li><li><a href=#from-poetry-to-uv>From <code>Poetry</code> to <code>uv</code></a></li></ul></li><li><a href=#judgment-over-tool-worship>Judgment over Tool Worship</a></li><li><a href=#exercises>Exercises</a><ul><li><a href=#1-uv-vs-pip--venv>1. <code>uv</code> vs. <code>pip</code> + <code>venv</code></a></li><li><a href=#2-uv-vs-poetry>2. <code>uv</code> vs. <code>Poetry</code></a></li><li><a href=#3-when-uv-is-sufficient>3. When <code>uv</code> is sufficient</a></li><li><a href=#4-migration-principles>4. Migration Principles</a></li></ul></li></ul></nav></div></aside></main></body></html>